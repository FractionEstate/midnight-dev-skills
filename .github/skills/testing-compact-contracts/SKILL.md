---
name: testing-compact-contracts
description: Guide for testing Midnight Compact smart contracts using Vitest and generated JavaScript implementations. Use when users need to write unit tests, integration tests, or validate circuit behavior. Triggers on contract testing, Vitest setup, circuit verification, or test coverage requests.
---

# Testing Compact Smart Contracts

Test Midnight Compact contracts using the JavaScript implementation generated by the compiler.

## Setup

```bash
npm install --save-dev vitest @types/node typescript
```

**vitest.config.ts**:
```typescript
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    include: ['tests/**/*.test.ts'],
  },
});
```

**package.json**:
```json
{
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage"
  }
}
```

## Import Contract

```typescript
// tests/counter.test.ts
import { Contract } from '../contracts/managed/counter/contract/index.cjs';

describe('Counter Contract', () => {
  let contract: InstanceType<typeof Contract>;

  beforeEach(() => {
    contract = new Contract({});
  });

  it('should be defined', () => {
    expect(contract).toBeDefined();
  });
});
```

## Create Test Context

```typescript
function createContext(state: any) {
  return {
    originalState: state,
    transactionContext: {
      timestamp: Date.now(),
      blockNumber: 1,
    },
  };
}
```

## Test Circuit Execution

```typescript
describe('Counter circuits', () => {
  it('should increment counter', () => {
    const ctx = createContext({ counter: 5 });

    const result = contract.circuits.increment(ctx);

    expect(result.newState.counter).toBe(6);
  });

  it('should decrement counter', () => {
    const ctx = createContext({ counter: 10 });

    const result = contract.circuits.decrement(ctx);

    expect(result.newState.counter).toBe(9);
  });

  it('should initialize to zero', () => {
    const ctx = createContext({});

    const result = contract.circuits.initialize(ctx);

    expect(result.newState.counter).toBe(0);
  });
});
```

## Test Constraints (require)

```typescript
it('should fail when decrementing below zero', () => {
  const ctx = createContext({ counter: 0 });

  expect(() => {
    contract.circuits.decrement(ctx);
  }).toThrow();
});

it('should enforce access control', () => {
  const ctx = createContext({
    owner: 'addr1',
    caller: 'addr2'  // Not owner
  });

  expect(() => {
    contract.circuits.adminAction(ctx);
  }).toThrow();
});
```

## Verify Proof Data

```typescript
it('should generate proof data', () => {
  const ctx = createContext({ counter: 0 });

  const result = contract.circuits.increment(ctx);

  expect(result.proofData).toBeDefined();
  expect(result.proofData.publicInputs).toBeDefined();
  expect(result.proofData.privateInputs).toBeDefined();
});
```

## Test State Transitions

```typescript
describe('State Machine', () => {
  it('CREATED -> ACTIVE transition', () => {
    const ctx = createContext({ state: 'CREATED' });

    const result = contract.circuits.start(ctx);

    expect(result.newState.state).toBe('ACTIVE');
  });

  it('should reject invalid transitions', () => {
    const ctx = createContext({ state: 'ENDED' });

    expect(() => {
      contract.circuits.start(ctx);  // Can't start from ENDED
    }).toThrow();
  });
});
```

## Test with Mock Witnesses

```typescript
const mockWitness = {
  getSecretKey: () => Buffer.from('0'.repeat(64), 'hex'),
  getAddress: () => 'mock-address-123',
};

const contract = new Contract(mockWitness);
```

## Test Organization

```
tests/
├── contracts/
│   ├── counter.test.ts
│   ├── voting.test.ts
│   └── auction.test.ts
├── integration/
│   └── full-workflow.test.ts
├── helpers/
│   ├── context.ts
│   └── mocks.ts
└── setup.ts
```

## Coverage Report

```bash
npm run test:coverage
```

**Expected output**:
```
 ✓ tests/counter.test.ts (5)
 ✓ tests/voting.test.ts (8)

Coverage:
  counter.compact    | 100% | 100% | 100%
  voting.compact     |  95% |  90% | 100%
```

## Best Practices

| Practice | Why |
|----------|-----|
| Test each circuit | Ensure all paths work |
| Test constraints | Verify require() enforcement |
| Test edge cases | Boundary conditions |
| Test state transitions | Valid/invalid paths |
| Fresh context per test | Isolation |
| Descriptive names | Readability |

## Resources

- Vitest Docs: https://vitest.dev/
- Midnight Testing Guide: https://docs.midnight.network/develop/tutorials/
