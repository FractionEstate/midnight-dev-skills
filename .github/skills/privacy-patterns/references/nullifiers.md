# Nullifier Patterns

Prevent double-use without revealing identity.

## What is a Nullifier?

A nullifier is a unique identifier derived from a secret that:

- Can only be generated by the owner
- Reveals nothing about the owner's identity
- Can only be used once

```text
nullifier = hash(secret, commitment)
```

## Core Concept

```text
┌────────────────┐     ┌────────────────┐     ┌────────────────┐
│    DEPOSIT     │────▶│   NULLIFIER    │────▶│   WITHDRAW     │
│                │     │                │     │                │
│ Create         │     │ nullifier =    │     │ Check not in   │
│ commitment     │     │ hash(secret,   │     │ set, then add  │
│                │     │ commitment)    │     │                │
└────────────────┘     └────────────────┘     └────────────────┘
```

## Basic Nullifier Pattern

```compact
pragma language_version 0.18;

import CompactStandardLibrary;

ledger commitments: Set<Field>;
ledger nullifiers: Set<Field>;

witness secret: Field;

// Deposit: create commitment
export circuit deposit(amount: Uint<64>): Field {
  // Commitment = hash(secret, amount)
  const commitment = persistentCommit(amount, secret);
  commitments.insert(commitment);

  receive(nativeToken(), amount);
  return commitment;
}

// Withdraw: use nullifier
export circuit withdraw(amount: Uint<64>, commitment: Field): [] {
  // Verify commitment opens correctly
  assert persistentCommit(amount, secret) == commitment;

  // Verify commitment exists
  assert commitments.member(commitment);

  // Compute nullifier
  const nullifier = transientHash(secret, commitment);

  // Check not already spent
  assert !nullifiers.member(nullifier);

  // Mark as spent
  nullifiers.insert(nullifier);

  // Send funds
  send(nativeToken(), amount, recipient);
}
```

## Why Nullifiers Work

| Property | Explanation |
| -------- | ----------- |
| **Prevents double-spend** | Same (secret, commitment) always gives same nullifier |
| **Preserves privacy** | Cannot link nullifier back to depositor |
| **Deterministic** | Owner can always compute their nullifier |

## Advanced: Private Token Transfer

```compact
ledger commitments: MerkleTree<20, Field>;
ledger nullifiers: Set<Field>;

witness secret: Field;
witness merkleProof: Vector<20, Field>;
witness proofIndices: Vector<20, Boolean>;

// Private transfer
export circuit transfer(
  amount: Uint<64>,
  inputCommitment: Field,
  outputCommitment: Field,
  recipientCommitment: Field
): [] {
  // 1. Verify input commitment exists (Merkle proof)
  assert verifyMerkle(inputCommitment, merkleProof, proofIndices);

  // 2. Verify we know the opening
  assert persistentCommit(amount, secret) == inputCommitment;

  // 3. Create and check nullifier
  const nullifier = transientHash(secret, inputCommitment);
  assert !nullifiers.member(nullifier);
  nullifiers.insert(nullifier);

  // 4. Add new commitments (change + recipient)
  commitments.insert(outputCommitment);
  commitments.insert(recipientCommitment);
}

// Helper: Merkle verification
circuit verifyMerkle(leaf: Field, proof: Vector<20, Field>, indices: Vector<20, Boolean>): Boolean {
  let current = leaf;
  for i in 0..20 {
    current = if indices[i] {
      persistentHash(proof[i], current)
    } else {
      persistentHash(current, proof[i])
    };
  }
  return current == commitments.root();
}
```

## Use Cases

### One-Time Tokens

```compact
ledger tokens: Set<Field>;
ledger usedTokens: Set<Field>;

witness tokenSecret: Field;

// Issue token
export circuit issueToken(tokenId: Bytes<32>): Field {
  const token = persistentHash(tokenId, tokenSecret);
  tokens.insert(token);
  return token;
}

// Use token (once only)
export circuit useToken(tokenId: Bytes<32>): [] {
  const token = persistentHash(tokenId, tokenSecret);
  const nullifier = transientHash(tokenSecret, token);

  assert tokens.member(token);
  assert !usedTokens.member(nullifier);

  usedTokens.insert(nullifier);
  // Token action...
}
```

### Anonymous Credential

```compact
ledger credentials: Set<Field>;
ledger usedCredentials: Set<Field>;

witness credentialSecret: Field;

// Issue credential
export circuit issueCredential(userId: Bytes<32>, credType: Uint<8>): Field {
  const credential = persistentCommit((userId, credType), credentialSecret);
  credentials.insert(credential);
  return credential;
}

// Use credential without revealing identity
export circuit useCredential(userId: Bytes<32>, credType: Uint<8>): [] {
  // Prove we have valid credential
  const credential = persistentCommit((userId, credType), credentialSecret);
  assert credentials.member(credential);

  // Create use-specific nullifier
  const nullifier = transientHash(credentialSecret, credential);
  assert !usedCredentials.member(nullifier);
  usedCredentials.insert(nullifier);

  // Perform action without revealing userId
}
```

### Voting with Nullifiers

```compact
ledger voters: Set<Field>;
ledger votedNullifiers: Set<Field>;
ledger yesCount: Counter;
ledger noCount: Counter;

witness voterSecret: Field;

// Register voter
export circuit registerVoter(voterId: Bytes<32>): [] {
  const voterCommitment = persistentHash(voterId, voterSecret);
  voters.insert(voterCommitment);
}

// Vote anonymously
export circuit vote(voterId: Bytes<32>, voteYes: Boolean): [] {
  // Verify registered voter
  const voterCommitment = persistentHash(voterId, voterSecret);
  assert voters.member(voterCommitment);

  // Create vote nullifier
  const nullifier = transientHash(voterSecret, voterCommitment);
  assert !votedNullifiers.member(nullifier);
  votedNullifiers.insert(nullifier);

  // Count vote (privately)
  if voteYes { yesCount = yesCount + 1; }
  else { noCount = noCount + 1; }
}
```

## Nullifier Best Practices

1. **Use transientHash** for nullifiers (not stored after tx)
2. **Include commitment** in nullifier to bind to specific use
3. **Store nullifiers in Set** for O(1) lookup
4. **Check before insert** - always verify nullifier is new
5. **Secret management** - users must safely store their secrets
6. **Consider linkability** - same secret across actions may link them
