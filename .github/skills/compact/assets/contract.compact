// Compact v0.18 Contract Template
// A slightly larger, *up-to-date* example that demonstrates:
// - structured config stored on-ledger
// - witness-based caller identity
// - Map/Set usage (no deprecated indexing/default syntax)
// - explicit disclosure when writing public state
// - a simple commitment pattern

pragma language_version 0.18;

import CompactStandardLibrary;

// ============================================
// Type Definitions
// ============================================

struct Config {
  admin: Bytes<32>,
  enabled: Boolean,
  maxValue: Uint<64>,
}

// ============================================
// Ledger State
// ============================================

export ledger counter: Uint<64>;
export ledger config: Config;
export ledger balances: Map<Bytes<32>, Uint<64>>;
export ledger authorized: Set<Bytes<32>>;

// Optional: commitment storage (caller -> commitment)
export ledger commitments: Map<Bytes<32>, Bytes<32>>;

// ============================================
// Identity (Witness)
// ============================================

// DApp must provide an implementation for this witness.
witness secretKey(): Bytes<32>;

circuit addressOf(sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([
    pad(32, "midnight:example:contract:addr"),
    sk,
  ]);
}

circuit callerAddress(): Bytes<32> {
  // Returning/using this publicly is intentional (it does not reveal the secret key).
  return disclose(addressOf(secretKey()));
}

// ============================================
// Constructor
// ============================================

constructor(adminAddress: Bytes<32>, maxValue: Uint<64>) {
  const admin = disclose(adminAddress);
  config = disclose(Config {
    admin: admin,
    enabled: true,
    maxValue: disclose(maxValue),
  });

  // Admin is automatically authorized
  authorized.insert(admin);
}

// ============================================
// Read Circuits
// ============================================

export circuit getCounter(): Uint<64> {
  return counter;
}

export circuit isAuthorized(addr: Bytes<32>): Boolean {
  return authorized.member(disclose(addr));
}

circuit getBalanceInternal(addr: Bytes<32>): Uint<64> {
  return balances.member(addr) ? balances.lookup(addr) : 0;
}

export circuit getBalance(addr: Bytes<32>): Uint<64> {
  return getBalanceInternal(disclose(addr));
}

// ============================================
// Write Circuits
// ============================================

export circuit increment(): Uint<64> {
  assert(config.enabled, "Contract is disabled");
  assert(counter < config.maxValue, "Maximum value reached");

  counter = disclose((counter + 1) as Uint<64>);
  return counter;
}

export circuit setCounter(value: Uint<64>): [] {
  const caller = callerAddress();
  assert(authorized.member(caller), "Not authorized");
  assert(value <= config.maxValue, "Value exceeds maximum");
  counter = disclose(value);
}

export circuit deposit(amount: Uint<64>): [] {
  const caller = callerAddress();
  const current = getBalanceInternal(caller);
  balances.insert(caller, disclose((current + amount) as Uint<64>));
}

export circuit withdraw(amount: Uint<64>): [] {
  const caller = callerAddress();
  const bal = getBalanceInternal(caller);
  assert(bal >= amount, "Insufficient balance");
  balances.insert(caller, bal - amount);
}

// ============================================
// Admin Circuits
// ============================================

export circuit authorize(addr: Bytes<32>): [] {
  const caller = callerAddress();
  assert(caller == config.admin, "Only admin can authorize");
  authorized.insert(disclose(addr));
}

export circuit revoke(addr: Bytes<32>): [] {
  const caller = callerAddress();
  const target = disclose(addr);
  assert(caller == config.admin, "Only admin can revoke");
  assert(target != config.admin, "Cannot revoke admin");
  authorized.remove(target);
}

export circuit updateConfig(enabled: Boolean, maxValue: Uint<64>): [] {
  const caller = callerAddress();
  assert(caller == config.admin, "Only admin can update config");

  config = disclose(Config {
    admin: config.admin,
    enabled: disclose(enabled),
    maxValue: disclose(maxValue),
  });
}

// ============================================
// Commitment Example
// ============================================

// Commit a secret value by storing only a commitment on-ledger.
// Anyone can later verify a reveal off-chain by recomputing the commitment.
export circuit commitValue(value: Field, nonce: Bytes<32>): Bytes<32> {
  const caller = callerAddress();
  const commitment = persistentCommit(value, nonce);
  commitments.insert(caller, disclose(commitment));
  return disclose(commitment);
}
