pragma language_version 0.18;

import CompactStandardLibrary;

// Commitment-Reveal Contract Template
// Two-phase pattern for fair auctions, sealed bids, etc.

export enum Phase { COMMIT, REVEAL, FINALIZED }

export ledger phase: Phase;
export ledger commitDeadline: Uint<64>;
export ledger revealDeadline: Uint<64>;

// Store commitments (address -> commitment)
export ledger commitments: Map<Bytes<32>, Bytes<32>>;
export ledger revealed: Map<Bytes<32>, Uint<64>>;
export ledger hasCommitted: Set<Bytes<32>>;
export ledger hasRevealed: Set<Bytes<32>>;

// DApp-provided witness for the committer's secret key
witness secretKey(): Bytes<32>;

circuit addressOf(sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([
    pad(32, "midnight:example:commit-reveal:addr"),
    sk,
  ]);
}

constructor(commitDeadlineTimestamp: Uint<64>, revealDeadlineTimestamp: Uint<64>) {
  phase = Phase::COMMIT;
  commitDeadline = disclose(commitDeadlineTimestamp);
  revealDeadline = disclose(revealDeadlineTimestamp);
  assert(commitDeadline < revealDeadline, "Invalid deadlines");
}

// Submit a commitment (hides the actual value)
export circuit commit(value: Uint<64>, randomness: Bytes<32>): [] {
  assert(phase == Phase::COMMIT, "Not in COMMIT phase");
  assert(blockTimeLt(commitDeadline), "Commit period ended");

  const who = disclose(addressOf(secretKey()));
  assert(!hasCommitted.member(who), "Already committed");

  const commitment = persistentCommit(value, randomness);
  commitments.insert(who, disclose(commitment));
  hasCommitted.insert(who);
}

// Transition to reveal phase
export circuit startReveal(): [] {
  assert(phase == Phase::COMMIT, "Not in COMMIT phase");
  assert(blockTimeGte(commitDeadline), "Commit period still active");
  phase = Phase::REVEAL;
}

// Reveal the committed value
export circuit reveal(value: Uint<64>, randomness: Bytes<32>): [] {
  assert(phase == Phase::REVEAL, "Not in REVEAL phase");
  assert(blockTimeLt(revealDeadline), "Reveal period ended");

  const who = disclose(addressOf(secretKey()));
  assert(hasCommitted.member(who), "No commitment found");
  assert(!hasRevealed.member(who), "Already revealed");

  const storedCommitment = commitments.lookup(who);
  const computedCommitment = persistentCommit(value, randomness);
  assert(computedCommitment == storedCommitment, "Commitment mismatch");

  // Store revealed value (this intentionally makes the value public)
  revealed.insert(who, disclose(value));
  hasRevealed.insert(who);
}

// Finalize after reveal period
export circuit finalize(): [] {
  assert(phase == Phase::REVEAL, "Not in REVEAL phase");
  assert(blockTimeGte(revealDeadline), "Reveal period still active");
  phase = Phase::FINALIZED;
}

export circuit getMyRevealedValue(): Uint<64> {
  assert(phase == Phase::FINALIZED, "Not finalized");
  const who = disclose(addressOf(secretKey()));
  assert(hasRevealed.member(who), "No revealed value for caller");
  return revealed.lookup(who);
}

// Get revealed value for an address (public query)
export circuit getRevealedValue(addr: Bytes<32>): Uint<64> {
  assert(phase == Phase::FINALIZED, "Not finalized");
  const who = disclose(addr);
  assert(hasRevealed.member(who), "No revealed value for address");
  return revealed.lookup(who);
}
