pragma language_version 0.18;

import CompactStandardLibrary;

// Token Contract Template
// Minimal token-like example.
//
// Notes:
// - This template demonstrates *valid Compact v0.18 syntax* and patterns.
// - "Caller" identity is not a built-in primitive; instead, use a witness + hash-based authorization
//   scheme (similar to the official "lock" example).

export ledger owner: Bytes<32>;
export ledger totalSupply: Uint<64>;
export ledger balances: Map<Bytes<32>, Uint<64>>;

// A local secret key. The DApp provides an implementation for this witness.
witness secretKey(): Bytes<32>;

// Derive an on-chain address from a secret key.
// This is not "real" public-key crypto: it's a hash-based identifier that can be proven in ZK.
circuit addressOf(sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([
    pad(32, "midnight:example:token:addr"),
    sk,
  ]);
}

// Helper: current user's address (explicitly allowed to be returned publicly)
export circuit myAddress(): Bytes<32> {
  return disclose(addressOf(secretKey()));
}

// Helper: read a balance, treating missing entries as 0.
circuit getBalance(addr: Bytes<32>): Uint<64> {
  return balances.member(addr) ? balances.lookup(addr) : 0;
}

constructor(ownerSk: Bytes<32>) {
  owner = disclose(addressOf(ownerSk));
  totalSupply = 0;
}

// Mint tokens (owner only)
export circuit mint(to: Bytes<32>, amount: Uint<64>): [] {
  const caller = disclose(addressOf(secretKey()));
  assert(caller == owner, "Only owner can mint");

  const toPub = disclose(to);
  const newBal = (getBalance(toPub) + amount) as Uint<64>;
  balances.insert(toPub, disclose(newBal));
  totalSupply = disclose((totalSupply + amount) as Uint<64>);
}

// Burn tokens (burn from caller)
export circuit burn(amount: Uint<64>): [] {
  const caller = disclose(addressOf(secretKey()));
  const bal = getBalance(caller);
  assert(bal >= amount, "Insufficient balance to burn");

  balances.insert(caller, bal - amount);
  totalSupply = totalSupply - amount;
}

// Transfer tokens (from caller to `to`)
export circuit transfer(to: Bytes<32>, amount: Uint<64>): [] {
  const from = disclose(addressOf(secretKey()));
  const toPub = disclose(to);

  const fromBal = getBalance(from);
  assert(fromBal >= amount, "Insufficient balance");

  balances.insert(from, fromBal - amount);
  balances.insert(toPub, (getBalance(toPub) + amount) as Uint<64>);
}

export circuit balanceOf(addr: Bytes<32>): Uint<64> {
  return getBalance(disclose(addr));
}
